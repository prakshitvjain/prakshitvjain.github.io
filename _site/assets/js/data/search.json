[
  
  {
    "title": "ScriptCTF 2025 Write-up",
    "url": "/posts/scriptCTF-2025/",
    "categories": "CTF Write-up",
    "tags": "ctf, write-up",
    "date": "2025-10-02 05:30:00 +0530",
    "content": "This write-up contains solutions of few challenges from ScriptCTF 2025, where I (solo) bagged 403rd place out of 1767 teams from all over the world. It contained challenges suitable for beginners to seasoned hackers. Do not miss the last challenge, I loved it the most.  Misc Rules  Just read the rules and you will have a link to prizes, the flag is on top right corner scriptCTF{600D_1ucK_5011D3r1}  Div  You are provided with a chall.py import os import decimal decimal.getcontext().prec = 50  secret = int(os.urandom(16).hex(),16) num = input('Enter a number: ')  if 'e' in num.lower():     print(\"Nice try...\")     exit(0)  if len(num) &gt;= 10:     print('Number too long...')     exit(0)  fl_num = decimal.Decimal(num) div = secret / fl_num  if div == 0:     print(open('flag.txt').read().strip()) else:     print('Try again...')   You have to find a way to enter a number that is large enough to divide the secret and result is 0.  Solution: Enter the input as Infinity   This will give you the flag scriptCTF{70_1nf1n17y_4nd_b3y0nd_f6c842098579}  Crypto RSA-1    out.txt   solve.py from gmpy2 import isqrt, iroot  # Given values n1 = 156503881374173899106040027210320626006530930815116631795516553916547375688556673985142242828597628615920973708595994675661662789752600109906259326160805121029243681236938272723595463141696217880136400102526509149966767717309801293569923237158596968679754520209177602882862180528522927242280121868961697240587 c1 = 77845730447898247683281609913423107803974192483879771538601656664815266655476695261695401337124553851404038028413156487834500306455909128563474382527072827288203275942719998719612346322196694263967769165807133288612193509523277795556658877046100866328789163922952483990512216199556692553605487824176112568965  n2 = 81176790394812943895417667822424503891538103661290067749746811244149927293880771403600643202454602366489650358459283710738177024118857784526124643798095463427793912529729517724613501628957072457149015941596656959113353794192041220905793823162933257702459236541137457227898063370534472564804125139395000655909 c2 = 40787486105407063933087059717827107329565540104154871338902977389136976706405321232356479461501507502072366720712449240185342528262578445532244098369654742284814175079411915848114327880144883620517336793165329893295685773515696260299308407612535992098605156822281687718904414533480149775329948085800726089284  n3 = 140612513823906625290578950857303904693579488575072876654320011261621692347864140784716666929156719735696270348892475443744858844360080415632704363751274666498790051438616664967359811895773995052063222050631573888071188619609300034534118393135291537302821893141204544943440866238800133993600817014789308510399 c3 = 100744134973371882529524399965586539315832009564780881084353677824875367744381226140488591354751113977457961062275480984708865578896869353244823264759044617432862876208706282555040444253921290103354489356742706959370396360754029015494871561563778937571686573716714202098622688982817598258563381656498389039630  e = 3  # Step 1: Verify GCDs to ensure pairwise coprimality from math import gcd gcd12 = gcd(n1, n2) gcd23 = gcd(n2, n3) gcd13 = gcd(n1, n3)  print(f\"GCD(n1, n2) = {gcd12}\") print(f\"GCD(n2, n3) = {gcd23}\") print(f\"GCD(n1, n3) = {gcd13}\")  # Assuming GCDs are 1 (pairwise coprime), proceed with CRT # Note: If GCDs are not 1, we‚Äôd need to factor the moduli, but let‚Äôs try CRT first  # Step 2: Compute m^3 using CRT # We use a simplified CRT implementation for three moduli def crt(a, n):     # a = [c1, c2, c3], n = [n1, n2, n3]     N = n[0] * n[1] * n[2]     result = 0     for i in range(3):         Ni = N // n[i]         # Compute modular inverse of Ni mod n[i]         y = pow(Ni, -1, n[i])  # Using Fermat‚Äôs little theorem or extended GCD         result += a[i] * Ni * y     return result % N, N  # Compute m^3 m3, N = crt([c1, c2, c3], [n1, n2, n3]) print(f\"m^3 mod N = {m3}\")  # Step 3: Check if m^3 &lt; N if m3 &lt; N:     print(\"m^3 is exact (no modular reduction needed)\") else:     print(\"m^3 &gt;= N, attack may fail or need adjustment\")     exit()  # Step 4: Compute the integer cube root m, exact = iroot(m3, 3) if exact:     print(f\"Plaintext m = {m}\") else:     print(\"Cube root is not exact, attack failed\")     exit()  # Step 5: Convert m to bytes and check if it‚Äôs a meaningful message try:     message = m.to_bytes((m.bit_length() + 7) // 8, byteorder='big')     print(f\"Message (bytes): {message}\")     # Try decoding as ASCII     print(f\"Message (ASCII): {message.decode('ascii')}\") except UnicodeDecodeError:     print(\"Message is not valid ASCII, outputting raw bytes\")     print(f\"Raw bytes: {message.hex()}\")  Used AI to write the above code‚Ä¶    flag scriptCTF{y0u_f0und_mr_yu's_s3cr3t_m3g_12a4e4}  Secure-server  Attachment: files.zip  You are provided with a capture.pcap file and a server.py file  server.py import os   from pwn import xor   print(\"With the Secure Server, sharing secrets is safer than ever!\")   enc = bytes.fromhex(input(\"Enter the secret, XORed by your key (in hex): \").strip())   key = os.urandom(32)   enc2 = xor(enc,key).hex()   print(f\"Double encrypted secret (in hex): {enc2}\")   dec = bytes.fromhex(input(\"XOR the above with your key again (in hex): \").strip())   secret = xor(dec,key)   print(\"Secret received!\", (secret).hex())   We observe the following from the packet capture file: Secret XORed with User Key (in hex): 151e71ce4addf692d5bac83bb87911a20c39b71da3fa5e7ff05a2b2b0a83ba03  Double encrypted secret (in hex): e1930164280e44386b389f7e3bc02b707188ea70d9617e3ced989f15d8a10d70  XOR the above with your key again (in hex): 87ee02c312a7f1fef8f92f75f1e60ba122df321925e8132068b0871ff303960e   solve.py from pwn import xor      # Replace these with the actual hex strings from the conversation   enc = bytes.fromhex(\"151e71ce4addf692d5bac83bb87911a20c39b71da3fa5e7ff05a2b2b0a83ba03\") ¬†# First input: secret XOR user's key   enc2 = bytes.fromhex(\"e1930164280e44386b389f7e3bc02b707188ea70d9617e3ced989f15d8a10d70\") # Output: double-encrypted secret   dec = bytes.fromhex(\"87ee02c312a7f1fef8f92f75f1e60ba122df321925e8132068b0871ff303960e\") ¬†# Second input: enc2 XOR user's key    # Compute secret = (dec XOR enc) XOR enc2   secret = xor(xor(dec, enc), enc2)   print(\"Secret (ASCII):\", secret.decode())      Explanation: XORing enc and dec cancels out user‚Äôs key, leaving us secret and enc2. When we XOR enc2 with secret and enc2 , we are left with just secret i.e flag. tip: look comments closely to understand how we are eliminating.    OSINT  Insider  Go to Noobmaster‚Äôs profile on discord.    Insider 2  Go to Noobmaster‚Äôs profile on discord. On his discord profile, scroll below you get link to login of 2026 ScriptCTF and link to his GitHub account.    on his GitHub, check his last commit  you get creds.txt    use the credentials to login. and boom!   Insider 3  Go to latest commits of GitHub account and you will get the flag    Web Renderer  We know that the cookie is at the following path    Grab the cookie    app.py   Only if we access the /developer directory with the correct cookie, we can get the flag.  Craft the magic request curl -X GET http://play.scriptsorcerers.xyz:10289/developer -H \"Cookie: developer_secret_cookie=400ba24a6f9e51dbbadd555e067c963ed1fe2430aa49a26de7ebe2a2019a5ed9\"      Forensics  pdf challenge.pdf  perform binwalk and extract the flag.txt.   diskchal    stick.img   you get a file stick.img  Perform binwalk and extracted a file flag.txt. binwalk -e stick.img cd _stick.img.extracted cat flag.txt  Flag:   Just Some Avocado This was my favorite challenge avocado.jpg  You are provided with a .jpg file, perform binwalk to extract it‚Äôs contents. Three files are provided    188F7.zip - password protected   justsomezip.zip - empty   staticnoise.wav - empty   Bruteforce 188F7.zip with rockyou.txt using fcrackzip to get the password  fcrackzip -u -D -p rockyou.txt 188F7.zip   impassive3428   You will be provided with 2 files    justsomezip.zip -  password protected   staticnoise.wav - normal audio file   To find the password of justsomezip.zip  Open Sonic Visualiser sonic-visualiser staticnoise.wav   Select Layer =&gt; Add Spectogram  Adjust to see the text clearly   d41v3ron  use the above password to extract the contents of the zip file.  We get flag.txt scriptCTF{1_l0ve_d41_v3r0n}   That‚Äôs a wrap. Meet you in future write-ups. Hope you learnt new things."
  },
  
  {
    "title": "NahamCon CTF 2025 Write-up",
    "url": "/posts/nahamcon-ctf-2025/",
    "categories": "CTF Write-up",
    "tags": "ctf, write-up",
    "date": "2025-06-01 05:30:00 +0530",
    "content": "NahamCon CTF 2025¬†write-up Hello folks, this is my first write-up for my first CTF contest, The NahamCon CTF 2025 by Ben Sadeghipour aka Nahamsec. I have covered warmup and easy challenges that i was able to solve.  So let‚Äôs begin  Read The Rules‚Ää‚Äî‚Ääwarmups  Challenge description: Please follow the rules for this CTF!  Just curl the rules page from terminal and grep flag  curl https://ctf.nahamcon.com/rules | grep flag     Screenshot‚Ää‚Äî‚Ääwarmups  You are provided with a PNG file ‚ÄòScreenshot.png‚Äô    This screenshot contains a hex dump of a zip file (since it starts with ‚ÄòPK‚Äô) named ‚Äòflag.zip‚Äô that contains a flag.txt we are also provided with a password called password in the challenge description.  Use below python script to re-create the zip file using the given hex dump!  hex_dump = \"\"\"     504b 0304 3300 0100 6300 2f02 b55a 0000     0000 4300 0000 2700 0000 0800 0b00 666c     6167 2e74 7874 0199 0700 0200 4145 0300     003d 42ff d1b3 5f95 0314 24f6 8b65 c3f5     7669 f14e 8df0 003f e240 b3ac 3364 859e     4c2d bc3c 36f2 d4ac c403 7613 85af e4e3     f90f bd29 d91b 614b a2c6 efde 11b7 1bcc     907a 72ed 504b 0102 3f03 3300 0100 6300     2f02 b55a 0000 0000 4300 0000 2700 0000     0800 2f00 0000 0000 0000 2080 b481 0000     0000 666c 6167 2e74 7874 0a00 2000 0000     0000 0100 1800 8213 8543 07ca db01 0000     0000 0000 0000 0000 0000 0000 0000 0199     0700 0200 4145 0300 0050 4b05 0600 0000     0001 0001 0065 0000 0074 0000 0000 00     \"\"\".replace(\"\\n\",\"\").replace(\" \",\"\")          binary = bytes.fromhex(hex_dump)     with open(\"flag.zip\",\"wb\") as f:        f.write(binary)     print(\"flag.zip created successfully!\") # to execute the script, simply type 'python filename.py' in the terminal  On successfull execution, the flag.zip will be created, unzip it and extract the flag.txt using the provided password to get the flag.  flag{907e5bb257cd5fc818e88a13622f3d46}  Free Flags!‚Ää‚Äî‚Ääwarmups  You are provided with a file ‚Äòfree_flags.txt‚Äô that contains 3000 flags.  There are a lot of flags in there, but what you need to do is just get the regex from rules page filter all the invalid flags!  grep -oE \"flag\\{[0-9a-f]{32}\\}\" free_flags.txt   This command will highlight and display the only valid flag    Naham-Commencement 2025‚Ää‚Äî‚Ääwarmups  You will be provided a login page and when you try SQL injection or any login attempt, you will be returned with ‚ÄòAccess Denied! Client-Side Validation failed‚Äô  Just Inspect the code and access the java-script file  To access the JS file: just press Ctrl + click on the script file in the inspector OR move to Debugger =&gt; Sources =&gt; Main Thread =&gt; Static/JS =&gt; main.js    If you look carefully, the user inputs are validated against pre-computed ciphertexts. And the functions perform Caeser Cipher and Vigenere Cipher for username and password respectively.  Ciphertext username¬†: dqxqcius¬† Perform Reverse Caeser Cipher with a shift of 16  Ciphertext password¬†: YeaTtgUnzezBqiwa2025 Perform Reverse Vigenere Cipher with Key¬†: nahamcon  Now use any external website to decrypt these ciphertexts to obtain credentials in plaintext.    username: nahamsec    password: LetTheGamesBegin2025  When you enter the obtained credentials, the flag will be displayed.    The Oddyssey‚Ää‚Äî‚Ääwarmups  You will be asked to connect to a netcat server which will display tiny chunks of the Poem Oddyssey and will prompt you to press &lt;enter&gt; key for next chunk.  I struggled with this challenge a bit, as it kept going infinitely. But then I figured that, on typing the ‚Äòn‚Äô number of characters and hitting enter, it skips the press &lt;enter&gt; part ‚Äôn‚Äô times and displays ‚Äòn‚Äô number of chunks in one go.  So I copy pasted a few chunks and hit enter, resulting in display of a huge number of chunks. Then I used ‚Äòfind‚Äô to search for the flag.  Better Approach  Execute the following command  while true; do echo \"\"; sleep 0.1; done | nc challenge.nahamcon.com 30132 | grep flag   This will send an empty string every 0.1 seconds indefinitely simulating the &lt;enter&gt; key. The ‚Äògrep flag‚Äô will highlight and display the flag.   Quartet‚Ää‚Äî‚Ääwarmups  In this Challenge, you will be provided with four files.    Challenge Description  If you view the contents of first file in a text editor, you will probably see that it starts with something like ‚ÄòPK‚Äô¬†, it likely means that it is the starting part of an incomplete zip file.  And the hint given with the challenge confirms it! i.e ‚Äúa collection of individual parts together‚Äù.  To construct the complete zip file, unzip it and display the flag, use below commands.  cat quartet.z01 quartet.z02 quartet.z03 quartet.z04 &gt; quartet.zip unzip quartet.zip strings quartet.jpeg | grep flag  The flag will be displayed    SNAD‚Ää‚Äî‚Ääweb  This is a particle simulation challenge, where we‚Äôre supposed to ‚Äúdrop grains of sand‚Äù with specific colors at specific positions.  Just Inspect the code and access the java-script file. To access the JS file: just press Ctrl + click on the script file in the inspector OR move to Debugger =&gt; Sources =&gt; Main Thread =&gt; JS =&gt; script.js      In the code, you will see that the target positions are given, a function called ‚ÄòinjectSand()‚Äô is defined. Not gonna lie, but I did use AI to solve this¬†:)  To solve this challenge we need to place the sand exactly at the target positions.  Navigate to Console in DevTools and type: injectSand(367, 238, 0); injectSand(412, 293, 40); injectSand(291, 314, 60); injectSand(392, 362, 120); injectSand(454, 319, 240); injectSand(349, 252, 280); injectSand(433, 301, 320);    Now, return back to the web page, the flag will be displayed    Cryptoclock‚Ää‚Äî‚ÄäCryptography  You‚Äôll connect to a remote server using netcat (nc), where a Python script (server.py) is running and controls the server‚Äôs behavior. ¬†You‚Äôll be given ‚Äòserver.py‚Äô to understand how the server works so you can interact with it correctly.¬†  When you connect with the server, it provides the encrypted flag.  What you also get: the ability to send a text and get its ciphertext.    On analyzing the server.py file, we come to know that the server is using XOR encryption with time based key. i.e it uses the timestamp to generate the key every session and uses same timestamp as key for that session alone.  We know that the flag is of the pattern ‚Äòflag{[0-9a-f]{32}}‚Äô‚Ää‚Äî‚Äämd5 Hash, So connect to the remote server and get the encrypted flag as well as the ciphertext of a sample flag ‚Äòflag{afd467a9fcb4e80ea3dr4dr5454fdaa0}‚Äô  Now the close the remote session and based on the steps followed to encrypt the flag, write a script to generate the key and decrypt the flag.  Logic:¬† XOR your plaintext with your ciphertext result ‚Üí that gives you the key¬† XOR that key with the encrypted flag ‚Üí you get the original flag in plaintext  Python Script  def XOR_operation(b1, b2):     return bytes([x ^ y for x,y in zip(b1,b2)])  # Replace the below value with the ciphertext of the original flag encrypted_flag_hex=\"6215c6614703787f8717186e1bc2b1567e6d6a0bfe0fec6245ad06f1575d283623a55ec7724c\"  # Replace the below value with the ciphertext of the flag you sent to server encrypted_plaintext_hex = \"6215c66147057b2d85164e6d4296b05f25683e0aaf0dbd3915a454f4505d29657ef45c91744c\"  # Replace this with the flag you sent to server plaintext_in_bytes_form = b\"flag{6ff0c72ad11bf174139e970559d9b5d2}\"  encrypted_flag = bytes.fromhex(encrypted_flag_hex) encrypted_plaintext = bytes.fromhex(encrypted_plaintext_hex)  key = XOR_operation(plaintext_in_bytes_form, encrypted_plaintext)  flag = XOR_operation(key, encrypted_flag)  print(flag.decode())  Executing this script will provide the flag. (make sure to change the values as per your scenario. But you will still get the flag with these exact values.)  Flagdle‚Ää‚Äî‚Äämiscellaneous    You can manually guess each character until all greens are received as response. Start with all a‚Äôs and go all the way to ‚Äòf‚Äô followed by integers (0‚Äì9). Replace only the ones that are either yellow or black. keep the green ones untouched.  Use the below command to send the POST request via curl curl -X POST http://challenge.nahamcon.com:30544/guess \\ -H 'Content-Type: application/json' \\ -d '{\"guess\":\"flag{aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa}\"}'  # make sure to change the PORT     Encoding: ud83d\\udfe9‚Ää‚Äî‚ÄäGreen ud83d\\udfe8‚Ää‚Äî‚ÄäYellow u2b1b‚Ää‚Äî‚ÄäBlack  Tip: Have a actual Flag and a rolling Flag, make changes to rolling flag when sending requests and make changes to actual flag only when the characters and their positions are confirmed._  You will eventually reach a point where all the responses are ud83d\\udfe9 i.e Green    Hence the flag that returns all greens is your answer!  The Martian‚Ää‚Äî‚Äämiscellaneous  You are provided with a file ‚Äòchallenge.martian‚Äô  Perform a ‚Äòbinwalk‚Äô on the file =&gt; extract the files # this will show the possible contents that can be extracted   binwalk challenge.martian   # the extracted files will be stored in _challenge.martian.extracted   binwalk -e challenge.martian  A directory ‚Äò_challenge.martian.extracted‚Äô will be created, navigate to the directory and you will see there are two JPEG files, that contain the flag.    Files ‚Äò34‚Äô and ‚Äò957D‚Äô contain the flag    That‚Äôs a wrap! Firstly, congratulations on making this far, I hope you liked it and got to learn something new. Thank you so much, see you in future write-ups."
  },
  
  {
    "title": "XSS (Cross Site Scripting)",
    "url": "/posts/owasp-xss/",
    "categories": "Web Security",
    "tags": "owasp, web",
    "date": "2025-05-26 05:30:00 +0530",
    "content": "Note: This blog is completely based on OWASP guide for prevention of Cross Site Scripting (XSS), but it is put in my own words so it can be understood in a simpler way.   Cross Site Scripting is a common vulnerability involving a scenario where the attacker can inject malicious scripts as input to web applications to force the application to perform unintended tasks. There is no single technique or rule to prevent or reduce the impact of XSS. It is required to use the right combination of techniques and rules that can protect the application from XSS.  Using modern web frameworks(React, Vue, Angular etc..), developers cover majority of the cases, but specific to the frameworks used, there are still minute gaps that can lead to serious damage. Output Encoding and Input Sanitization can act as critical defenses against XSS.  Output Encoding Output Encoding can be helpful when the application wants to safely display the data as the user as typed. Similar to SQL injections, here the input obtained from the user should be interpreted as text and not the part of the code.  How to implement it? Most frameworks perform output encoding by default, however, if you are not using a framework, then every variable in the user interface should be passed through an Output Encoding function.  Since different browsers parse HTML, CSS and JS differently, it is important to use appropriate encoding method, else it may introduce weaknesses as well as disturb the functionality of your application.  Output encoding prevents these attacks by converting the special characters that can trigger XSS, such as &lt;, &gt;, \", ' and &amp; into harmless HTML entities, such as &amp;lt;, &amp;gt;, &amp;quot;, &amp;apos;, and &amp;amp;. This way, the browser will treat the data as plain text and not as code.  Some popular Output Encoding Methods include: \tOWASP‚Äôs ESAPI \tPHP‚Äôs htmlspecialchars() \t.NET‚Äôs HtmlEncode() \tPython‚Äôs html.escape  HTML Context  This refers to inserting variable between two basic HTML tags like a &lt;div&gt; or a &lt;p&gt;.  For eg. &lt;div&gt; $unsafVar &lt;/div&gt;   An attacker could modify this $unsafeVar variable, which could lead to an attack.  &lt;div&gt; &lt;script&gt; alert('XSS') &lt;/script&gt; &lt;/div&gt;   To add a variable to a HTML context safely, HTML entity encoding can be used. When using JavaScript, .textContent attribute can be a safe way to add a variable.  HTML Attribute Contexts  This refers to when a variable is placed in a HTML attribute value. &lt;div attr='$unsafeVar'&gt; &lt;div attr=‚Äù*x‚Äù onblur=‚Äùalert(1)*‚Äù&gt;   It is important to surround the variable names with ' or \", as it makes it difficult for the attacker to change the context.  When using JavaScript, .setAttribute methods can prove as a defensive technique against XSS. These are relatively safe when attribute names are hard-coded such as id or class.  Attributes such as onmouseover, onclick etc are NOT safe to use with untrusted attribute values.  JavaScript Contexts  This refers to when variables are placed into inline JavaScript and then embedded into HTML document. The only secure way to place this way is to quote them. All other contexts are unsafe and not recommended. &lt;script&gt;alert('$variable')&lt;/script&gt; &lt;script&gt;x='$variable'&lt;/script&gt; &lt;div onclick=\"'$variable'\"&gt;&lt;/div&gt;  This way XSS can be prevented securely.  For JSON, the Content-Type should be application/json and not text/html to prevent XSS.  CSS Contexts  When variables are placed into inline CSS, the variables should only be placed in CSS property value. Other CSS contexts are unsafe and variable data should not be placed in them.  &lt;style&gt;selector {property : $variable;} &lt;/style&gt; &lt;style&gt;selector {property : '$variable';} &lt;/style&gt; &lt;span style=\"property:$variable\"&gt;oh god&lt;/span&gt;   It is recommended to use style.property = x.  URL Contexts  URL Contexts refer to places where the developers add a parameter to a URL. This is an unsafe way to add parameter to a URL.  &lt;a href=\"http://example.com?u_id=$variable\"&gt;Link&lt;/a&gt;   To implement this safely, you should perform URL encoding followed by HTML attribute encoding:  url = \"http://example.com?u_id=\" + urlencode(parameter) &lt;a href = \"attributeEncode(url)\"&gt;Link&lt;/a&gt;   Thank You for reading. See you in the next blog!"
  },
  
  {
    "title": "SQL Injection",
    "url": "/posts/sql-injection/",
    "categories": "Web Security",
    "tags": "owasp, web",
    "date": "2025-03-07 05:30:00 +0530",
    "content": "Note: This blog is completely based on OWASP guide for prevening SQL Injection Attacks, but it is put in my own words so it can be understood in a simpler way.   SQL injection is a process of injecting or inserting a SQL query as a user input from client to application, that may lead to obtaining sensitive data from the database, modify database, shutdown the DBMS and also issue commands to OS.  Threat Modeling     It allows attackers to spoof their identity, tamper with data and become administrator of database server.   SQL injection is common in PHP and ASP applications rather than j2EE and ASP.NET applications due to their respective programmatic interfaces.   It is a high impact severity.   SQL injection attack occurs when:     An unintended data enters a program from an untrusted source.   The data is used to dynamically construct a SQL query.   Anatomy of A Typical SQL Injection Vulnerability  Input Validation:  A common SQL injection vulnerability in Java is un-validated input from the user that is taken and appended to the query, and the input is executed as a part of the query. An attacker can manipulate the query in accordance to his will.  Take a look at the below example: String query = \"SELECT balance FROM account WHERE user_name = '\"  + request.getParameter(\"customerName\")\"'\":   If an attacker passes the username as admin OR 1=1  Or admin; DROP TABLE account   The query will look something like this SELECT balance FROM account WHERE user_name = 'admin' OR 1=1;  -- OR  SELECT balance FROM account WHERE user_name = 'admin'; DROP TABLE account;  Such attacks are very dangerous and compromise the security of Organization  So, what are the solutions to prevent these? Primary Defenses  1: Use of Prepared Statements (with Parameterized Queries) 2: Use of Properly Constructed Stored Procedures 3: Allow-list Input Validation 4: STRONGLY DISCOURAGED: Escaping All User Supplied Input   1. Parameterized queries (Prepared Statements)  The correct way to prevent SQL injection is to never concatenate user input directly into the query instead use parameterized queries (Prepared Statements). This ensures that the user input is treated as data and not the part of SQL code.  String query = \"SELECT balance FROM account WHERE user_name = ?\"; PreparedStatement stmt = connection.prepareStatement(query); stmt.setString(1,request.getParameter(\"customerName\")); ResultSet result = stmt.executeQuery();   This way the attacker will never be able to inject malicious SQL queries as input. Almost all the languages support parameterized queries. Even SQL abstraction layers like HQL (Hibernate Query Language) faces similar type of injection problems called HQL injection. Using prepared statements also makes your application relatively database independent.  2. Stored Procedures  Even though Stored procedures are not always safe from SQL injections, developers can use certain standard stored procedures constructs that are generally safe if implemented accordingly. Are they Safe?  To ensure security, the developers are required to create SQL statements with parameters that are automatically parameterized. The basic difference between prepared statements and stored procedures is that the SQL code for a stored procedure is stored in the database itself, and is called by the application. Hence making parameterized queries and stored procedures equally effective in safeguarding the application from SQL injection.  When use of Stored Procedures are a risk?  Stored Procedures can be a risk when a system is attacked. Consider an example where an application uses a MS SQL Server, with default roles like db_datareader , db_datawriter and db_owner. Before stored procedures came into use, DBAs (Database Administrators) would assign roles to users, depending on the requirements.  The default roles like  db_datareader , db_datawriter do not have rights to execute stored procedures, and in organizations where user management is centralized with just these 3 default roles, assigning db_owner to users would to a potential risk. If an attacker gains access to any of the users or a server, the attacker will have full rights to the database, where previously they had only read access.  A Secure Stored Procedure Example in Java // This input should be validated in terms of length and allowed characters using regular expressions String custname = request.getParameter(\"customerName\"); try { \tcallableStatement cs = connection.prepareCall(\"{call sp_getBalance(?)}\"); \tcs.setString(1,custname); \tResultSet rs = cs.executeQuery(); \t//manipulating recieved data } catch (SQLexception){ \t//logging and error messsage display }   This example uses Java‚Äôs stored procedure implementation using callableStatement to execute database queries. Where sp_getBalance is a stored procedure predefined in the database. The call in the {call sp_getBalance(?) is used to call the stored procedure and the ? represents the parameter placeholder.  3. Allow-List Input Validation  When faced with SQL queries that can‚Äôt use bind variables (parameterized queries) such as names of tables or columns and the sort order indicators (ASC or DESC) as well, input validation is the best defense. When names of tables and columns are needed, they should come from the code and not the user parameters.  A Secure Sample Example For Allow-List Input Validation  If user parameter values are used to target different tables and columns, then it is merely a symptom of a poor design and a full-redesigning should be considered. Otherwise the developers should map the parameter values to legal/valid table and column names, preventing the user input from ending up in the query.  Take a look at the Dynamic SQL generation String tableName; switch(parameter){ \tcase \"valueA\": \t\ttableName = \"ordersTable\"; \t\tbreak; \tcase \"valueB\": \t\ttableName = \"shippedTable\"; \t\tbreak; \tdefault: \t\tthrow new InpuExceptionError(\"Invalid input for table name\"); }   In the above example the tableName is declared and using switch, the user input i.e parameter is validated and a value is assigned to tablename depending upon different cases. If input is valueA then the value of tableName will be \"ordersTable\". The default block handles the errors and exceptions effectively. Here the query is dynamically generated based on the user input but it is secure as it is validated prior to acceptance.  When to use this Allow-List Input Validation ?  When we say stored procedures are safe, It is assumed that the stored procedures do not include dynamic SQL code generation. It is usually avoided by the developers. But in some scenarios, if there is a need for dynamic SQL code generation, the Allow-list input method or proper escaping must be used to secure the program.  A safer way to implement Dynamic Query Generation  For something simple like sort order, it would be a better way to first convert the user supplied data to boolean and then use the boolean value to determine the legal value, that is appended to the query.  For example public String someMethod (boolean parameter) { \tString query = \" SELECT * FROM employees ORDER BY salary \" + (parameter ? \"ASC\" : \"DESC\"); \treturn query; }   Like the above example, if possible it is always safer to convert any user input to a non-string format like integer, boolean, time, date, etc. before it is appended to query or used to select a value to append to a query.  Input validation is recommended as a secondary defense in all cases even when using prepared statements or stored procedures to ensure maximum security.  4. Escaping All User-Supplied Input  In this approach, the developer will have to escape all the input supplied by the user before appending it to a query. Escaping input refers to ensuring that any special characters in user-supplied input are converted or escaped into a safe form before they are included in an SQL query. This defense method is highly discouraged as it does not guarantee safety due to various limitations.  How does Escaping work?  For each special character that might interfere with the query, you replace or escape it with a safe equivalent. Different Databases have different ways of handling escaping.  Below are few common SQL special characters and their functions    Single Quote ('): Used to delimit strings in SQL.   Double Quote (\"): Often used for quoting column or table names.   Backslash (\\): Used as an escape character in many SQL implementations.   Semicolon (;): Indicates the end of a SQL statement.   Comment (-- or /* ... */): Allows attackers to comment out the remainder of a query.   Escaping single quotes ('):  Take a look at below query String query = 'SELECT * FROM accounts WHERE username = ' + request.getParameter(\"custName\"); ResultSet rs = stmt.executeQuery(query);   If the user supplied input is O'Rielly, then the query will break and result in error.  To avoid broken queries, the developer must escape the (') manually. This can be done using doubling the single quotes ('').  A solution to escaping only single quotes (') in Java  String UserInput = request.getParameter(\"custName\"); //Input = O'Rielly String EscapedInput = UserInput.replace(\"'\",\"''\"); //Now manually construct the query String query = \"SELECT * FROM accounts WHERE username = '\" + EscapedInput + \"'\"); ResultSet rs = stmt.executeQuery(query);   This example will not return errors, when provided with input O'Rielly. Similarly for different special characters, different escaping methods are to be used. But such practices are highly discouraged as escaping all the user input is very unsafe. Even though the developers cover all edge cases, there is still a huge risk of SQL injection attacks. Better Alternatives like prepared statements are highly recommended.  Additional Defenses  In Addition to implementing any one of the four primary defenses, these additional defenses can also be implemented for maximizing the security of the application. The additional defenses are:    Least Privilege   Allow-List Input Validation   Least Privilege  To minimize the damage of a successful SQL injection attack, consider minimizing the privileges assigned to the every database account in your environment i.e The principle of least privilege (PoLP). Use Bottom-Up approach, always start from what access the application accounts require rather than focusing what access you need to take away.  Accounts that require to only read the data should be given only read privileges and follow the same for write, provide only if absolutely necessary. DO NOT grant DBA or ADMIN privileges to any of the application accounts. Even though it is easy to do so and everything just functions normally but it is extremely dangerous.  What is an Application Account?  Application Account refers to a database user account that acts as a bridge between the web application and the database. It is not a person or a software It is just the database account that the web application software uses to store or retrieve data from the database. Any Application account should not contain Admin privileges like DROP,DELETE or ALTER.  Minimizing Application and OS privileges  Application privilege  In addition to SQL injection Attacks, there exist other threats to your database data, such as attackers manipulating the parameters from a legal value that is authorized for their current account to a value that is unauthorized for them (only meant to be accessible to root or the the admin).  For Example Consider an application where user-supplied input is appended to query the database directly. Even if the user-input is validated using javaScript, the attacker could still modify the URL like this: https://flipkart.com/product?id=322  To https://flipkart.com/product?id=999        //To be accessed only by admin   Since the user-input validation is on the client-side, the attacker can easily bypass the authentication. This is why the input-validation should always be done on the server side where attacker has no control. Even if an attacker gains access to a Application account, to minimize the damage, the privileges assigned to the account should be minimal.  OS privilege  The OS (Operating System) Account under which the DBMS (Database Management System) runs under should never be run as root or system. By default most DBMSs run as system account which is very powerful and dangerous. It is recommended to run the DBMS with an appropriate account with restricted privileges.  To create a new user:  Login to MySQL as root user sudo mysql -u root -p   Now create a new user with restricted privileges using the following command CREATE USER 'user_a'@'localhost' IDENTIFIED BY 'password'; GRANT SELECT ON mydatabase.* TO 'user_a'@'localhost'; FLUSH PRIVILEGES;   This way only the necessary privileges are to be assigned to the user account on the OS that runs the DBMS. To create new user application accounts on the database to be accessed from different devices, the 'localhost' should be simply replaced by ('%') meaning that it allows any host with the password to access the database which might be a threat if passwords are weak. So it is recommended to limit the access for IP range using '192.13.32.%'. This provides remote access and also maintaining security.  Additional Measures When Developing  When assigning privileges, if an application account needs access to only few tables, consider creating a VIEW that limits only to required data and providing access to only that view instead, rather that the actual table.  If you plan to use stored procedures everywhere, then do not allow application accounts to execute queries directly, rather only allow them to execute stored procedures that they require. Avoid giving them direct access to tables in the database.  Least Admin Privileges For Multiple Database User Accounts  The developers should refrain from using the same root or admin account for multiple web applications to connect to the database. Different application accounts are to be used for different web applications.  Each and every web application must have a designated database account with least privileges that it requires to connect to the database. This can help reduce the privileges to the web applications.  For example, consider a ‚ÄòLogin‚Äô, ‚ÄòSign-Up‚Äô and ‚ÄòProfile Page‚Äô web applications. Here providing admin or same account to all three web applications would be a poor decision. The ‚ÄòLogin‚Äô requires only SELECT access, whereas ‚ÄòSign-Up‚Äô requires only INSERT access and the ‚ÄòProfile Page‚Äô application requires SELECT , INSERT and UPDATE access. Hence least privilege can be maximized.  Enhancing Least Privilege with SQL Views  You can use SQL views to enhance the granularity of access by limiting the read access to specific data of a table. For Example, consider storing password in plain-text instead of salty-hash values (due to specific legal requirements) in the table. If an application account is to be given access to the passwords, then a view is to be generated that depicts the hash values of the passwords. The access to the tables in the database is revoked from all the DB users except admin.  If a successful SQL injection attack occurs, the attacker might have access to only salted-hash values of the passwords and not the plain-text passwords, Since no application user has access to the table itself.  Allow-List Input Validation  As mentioned earlier implementing Input Validation as a primary defense only if nothing else works, but implementing it as a secondary defense in highly recommended to improve security. As explained in above section, it is used to detect unauthorized input before appending to the query. Proceed with caution, Input validation is highly discouraged as a primary defense, unless it is the only option.  That‚Äôs a wrap. Firstly, congratulations on making it so far. You have done a great job, wishing you Best of luck!"
  },
  
  {
    "title": "HTTP Server with Fil-C",
    "url": "/posts/http-server/",
    "categories": "Projects",
    "tags": "C, project, fil-c, server",
    "date": "2023-06-17 05:30:00 +0530",
    "content": "A simple HTTP server written in C that demonstrates real memory safety using Fil-C. The code contains patterns that would be easily exploitable in normal C, but Fil-C‚Äôs runtime protection catches all memory safety violations.  Installation and Execution  Step 1: Install Dependencies  First, ensure your system has the necessary tools to handle the downloads and execution environment.  # the below commands are for fedora or Red Hat based OSs, ensure you use appropriate command for your distro eg. apt for debian based systems. sudo dnf update sudo dnf install git wget xz python3 cmake ninja-build gcc gcc-c++ patchelf   Step 2: Download the Fil-C  Download and Extract: Check fil-c.org for the latest version  mkdir ~/filc_project &amp;&amp; cd ~/filc_project wget https://fil-c.org/download/filc-0.677-linux-x86_64.tar.xz tar -xf filc-0.677-linux-x86_64.tar.xz cd filc-0.677-linux-x86_64   Run Setup:  ./setup.sh   Step 3: Compile with Fil-C  Instead of using standard gcc, you must use the Fil-C compiler located in the build/bin directory.  build/bin/clang -O2 -g -o server server.c   # flags  -O2: Standard optimization.  -g: Includes debugging information (highly recommended for Fil-C to provide better error reports).  -o server: Names your output program.  Step 4: Run the Program  Now you can start your memory-safe server:  ./server   You should see the message: Starting Server on port 8080  Download the Script          üì• Download server.c"
  },
  
  {
    "title": "Linux Hardening using Python",
    "url": "/posts/linux-hardening/",
    "categories": "Projects",
    "tags": "linux, python, hardening, project",
    "date": "2023-02-27 05:30:00 +0530",
    "content": "Overview  This script performs automated system hardening by updating the configuration and recommending some manual checks that can help you secure your system and detect any suspicious behaviour.  What It Does  SSH Configuration - Modifies /etc/ssh/sshd_config to disable root login, enforce key-based auth, and prevent empty passwords.  File Permissions - Sets appropriate permissions on /etc/passwd (644), /etc/shadow (600), and /etc/group (644).  Firewall - Enables UFW with deny-incoming/allow-outgoing policy.  Manual Checks - Prompts for system updates, password policies, netstat output review, process inspection, unauthorized user detection, and sudoers validation.  Working  The script requires root privileges and uses subprocess to execute system commands. SSH hardening parses the existing sshd_config, preserves any custom settings, and enforces the security directives. File permissions are set using chmod, and UFW commands configure the firewall with safe defaults.  Interactive prompts guide you through manual security checks, things that need human judgment like reviewing running processes or checking for unauthorized user accounts.  Usage Guide  Prerequisites: Linux OS, Python 3.x, root access, UFW installed  To run the script: chmod +x linux_hardening.py sudo ./linux_hardening.py   Benefits &amp; Use Cases  Consistency: Uniform security across systems  Speed: Minutes instead of hours  Compliance: CIS Benchmark aligned  Educational: Teaches security best practices  Real-world applications: Personal use, educational labs, compliance audits.  Download the Script          üì• Download linux-hardening.py      Important Notes     Before running: Backup your system, test in a VM first, ensure SSH keys are configured      After running: Restart SSH (sudo systemctl restart sshd), test connectivity in a new session, review firewall rules"
  }
  
]

