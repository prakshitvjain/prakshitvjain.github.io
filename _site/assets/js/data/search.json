[
  
  {
    "title": "NahamCon CTF 2025 Write-up",
    "url": "/posts/nahamcon-ctf-2025/",
    "categories": "",
    "tags": "ctf, write-up",
    "date": "2025-06-01 05:30:00 +0530",
    "content": "NahamCon CTF 2025 write-up Hello folks, this is my first write-up for my first CTF contest, The NahamCon CTF 2025 by Ben Sadeghipour aka Nahamsec. I have covered warmup and easy challenges that i was able to solve.  So let’s begin  Read The Rules — warmups  Challenge description: Please follow the rules for this CTF!  Just curl the rules page from terminal and grep flag  curl https://ctf.nahamcon.com/rules | grep flag     Screenshot — warmups  You are provided with a PNG file ‘Screenshot.png’    This screenshot contains a hex dump of a zip file (since it starts with ‘PK’) named ‘flag.zip’ that contains a flag.txt we are also provided with a password called password in the challenge description.  Use below python script to re-create the zip file using the given hex dump!  hex_dump = \"\"\"     504b 0304 3300 0100 6300 2f02 b55a 0000     0000 4300 0000 2700 0000 0800 0b00 666c     6167 2e74 7874 0199 0700 0200 4145 0300     003d 42ff d1b3 5f95 0314 24f6 8b65 c3f5     7669 f14e 8df0 003f e240 b3ac 3364 859e     4c2d bc3c 36f2 d4ac c403 7613 85af e4e3     f90f bd29 d91b 614b a2c6 efde 11b7 1bcc     907a 72ed 504b 0102 3f03 3300 0100 6300     2f02 b55a 0000 0000 4300 0000 2700 0000     0800 2f00 0000 0000 0000 2080 b481 0000     0000 666c 6167 2e74 7874 0a00 2000 0000     0000 0100 1800 8213 8543 07ca db01 0000     0000 0000 0000 0000 0000 0000 0000 0199     0700 0200 4145 0300 0050 4b05 0600 0000     0001 0001 0065 0000 0074 0000 0000 00     \"\"\".replace(\"\\n\",\"\").replace(\" \",\"\")          binary = bytes.fromhex(hex_dump)     with open(\"flag.zip\",\"wb\") as f:        f.write(binary)     print(\"flag.zip created successfully!\") # to execute the script, simply type 'python filename.py' in the terminal  On successfull execution, the flag.zip will be created, unzip it and extract the flag.txt using the provided password to get the flag.  flag{907e5bb257cd5fc818e88a13622f3d46}  Free Flags! — warmups  You are provided with a file ‘free_flags.txt’ that contains 3000 flags.  There are a lot of flags in there, but what you need to do is just get the regex from rules page filter all the invalid flags!  grep -oE \"flag\\{[0-9a-f]{32}\\}\" free_flags.txt   This command will highlight and display the only valid flag    Naham-Commencement 2025 — warmups  You will be provided a login page and when you try SQL injection or any login attempt, you will be returned with ‘Access Denied! Client-Side Validation failed’  Just Inspect the code and access the java-script file  To access the JS file: just press Ctrl + click on the script file in the inspector OR move to Debugger =&gt; Sources =&gt; Main Thread =&gt; Static/JS =&gt; main.js    If you look carefully, the user inputs are validated against pre-computed ciphertexts. And the functions perform Caeser Cipher and Vigenere Cipher for username and password respectively.  Ciphertext username : dqxqcius  Perform Reverse Caeser Cipher with a shift of 16  Ciphertext password : YeaTtgUnzezBqiwa2025 Perform Reverse Vigenere Cipher with Key : nahamcon  Now use any external website to decrypt these ciphertexts to obtain credentials in plaintext.    username: nahamsec    password: LetTheGamesBegin2025  When you enter the obtained credentials, the flag will be displayed.    The Oddyssey — warmups  You will be asked to connect to a netcat server which will display tiny chunks of the Poem Oddyssey and will prompt you to press &lt;enter&gt; key for next chunk.  I struggled with this challenge a bit, as it kept going infinitely. But then I figured that, on typing the ‘n’ number of characters and hitting enter, it skips the press &lt;enter&gt; part ’n’ times and displays ‘n’ number of chunks in one go.  So I copy pasted a few chunks and hit enter, resulting in display of a huge number of chunks. Then I used ‘find’ to search for the flag.  Better Approach  Execute the following command  while true; do echo \"\"; sleep 0.1; done | nc challenge.nahamcon.com 30132 | grep flag   This will send an empty string every 0.1 seconds indefinitely simulating the &lt;enter&gt; key. The ‘grep flag’ will highlight and display the flag.   Quartet — warmups  In this Challenge, you will be provided with four files.    Challenge Description  If you view the contents of first file in a text editor, you will probably see that it starts with something like ‘PK’ , it likely means that it is the starting part of an incomplete zip file.  And the hint given with the challenge confirms it! i.e “a collection of individual parts together”.  To construct the complete zip file, unzip it and display the flag, use below commands.  cat quartet.z01 quartet.z02 quartet.z03 quartet.z04 &gt; quartet.zip unzip quartet.zip strings quartet.jpeg | grep flag  The flag will be displayed    SNAD — web  This is a particle simulation challenge, where we’re supposed to “drop grains of sand” with specific colors at specific positions.  Just Inspect the code and access the java-script file. To access the JS file: just press Ctrl + click on the script file in the inspector OR move to Debugger =&gt; Sources =&gt; Main Thread =&gt; JS =&gt; script.js      In the code, you will see that the target positions are given, a function called ‘injectSand()’ is defined. Not gonna lie, but I did use AI to solve this :)  To solve this challenge we need to place the sand exactly at the target positions.  Navigate to Console in DevTools and type: injectSand(367, 238, 0); injectSand(412, 293, 40); injectSand(291, 314, 60); injectSand(392, 362, 120); injectSand(454, 319, 240); injectSand(349, 252, 280); injectSand(433, 301, 320);    Now, return back to the web page, the flag will be displayed    Cryptoclock — Cryptography  You’ll connect to a remote server using netcat (nc), where a Python script (server.py) is running and controls the server’s behavior.  You’ll be given ‘server.py’ to understand how the server works so you can interact with it correctly.   When you connect with the server, it provides the encrypted flag.  What you also get: the ability to send a text and get its ciphertext.    On analyzing the server.py file, we come to know that the server is using XOR encryption with time based key. i.e it uses the timestamp to generate the key every session and uses same timestamp as key for that session alone.  We know that the flag is of the pattern ‘flag{[0-9a-f]{32}}’ — md5 Hash, So connect to the remote server and get the encrypted flag as well as the ciphertext of a sample flag ‘flag{afd467a9fcb4e80ea3dr4dr5454fdaa0}’  Now the close the remote session and based on the steps followed to encrypt the flag, write a script to generate the key and decrypt the flag.  Logic:  XOR your plaintext with your ciphertext result → that gives you the key  XOR that key with the encrypted flag → you get the original flag in plaintext  Python Script  def XOR_operation(b1, b2):     return bytes([x ^ y for x,y in zip(b1,b2)])  # Replace the below value with the ciphertext of the original flag encrypted_flag_hex=\"6215c6614703787f8717186e1bc2b1567e6d6a0bfe0fec6245ad06f1575d283623a55ec7724c\"  # Replace the below value with the ciphertext of the flag you sent to server encrypted_plaintext_hex = \"6215c66147057b2d85164e6d4296b05f25683e0aaf0dbd3915a454f4505d29657ef45c91744c\"  # Replace this with the flag you sent to server plaintext_in_bytes_form = b\"flag{6ff0c72ad11bf174139e970559d9b5d2}\"  encrypted_flag = bytes.fromhex(encrypted_flag_hex) encrypted_plaintext = bytes.fromhex(encrypted_plaintext_hex)  key = XOR_operation(plaintext_in_bytes_form, encrypted_plaintext)  flag = XOR_operation(key, encrypted_flag)  print(flag.decode())  Executing this script will provide the flag. (make sure to change the values as per your scenario. But you will still get the flag with these exact values.)  Flagdle — miscellaneous    You can manually guess each character until all greens are received as response. Start with all a’s and go all the way to ‘f’ followed by integers (0–9). Replace only the ones that are either yellow or black. keep the green ones untouched.  Use the below command to send the POST request via curl curl -X POST http://challenge.nahamcon.com:30544/guess \\ -H 'Content-Type: application/json' \\ -d '{\"guess\":\"flag{aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa}\"}'  # make sure to change the PORT     Encoding: ud83d\\udfe9 — Green ud83d\\udfe8 — Yellow u2b1b — Black  Tip: Have a actual Flag and a rolling Flag, make changes to rolling flag when sending requests and make changes to actual flag only when the characters and their positions are confirmed._  You will eventually reach a point where all the responses are ud83d\\udfe9 i.e Green    Hence the flag that returns all greens is your answer!  The Martian — miscellaneous  You are provided with a file ‘challenge.martian’  Perform a ‘binwalk’ on the file =&gt; extract the files # this will show the possible contents that can be extracted   binwalk challenge.martian   # the extracted files will be stored in _challenge.martian.extracted   binwalk -e challenge.martian  A directory ‘_challenge.martian.extracted’ will be created, navigate to the directory and you will see there are two JPEG files, that contain the flag.    Files ‘34’ and ‘957D’ contain the flag    That’s a wrap! Firstly, congratulations on making this far, I hope you liked it and got to learn something new. Thank you so much, see you in future write-ups."
  },
  
  {
    "title": "XSS (Cross Site Scripting)",
    "url": "/posts/owasp-xss/",
    "categories": "",
    "tags": "owasp, web",
    "date": "2025-05-26 05:30:00 +0530",
    "content": "Note: This blog is completely based on OWASP guide for prevention of Cross Site Scripting (XSS), but it is put in my own words so it can be understood in a simpler way.   Cross Site Scripting is a common vulnerability involving a scenario where the attacker can inject malicious scripts as input to web applications to force the application to perform unintended tasks. There is no single technique or rule to prevent or reduce the impact of XSS. It is required to use the right combination of techniques and rules that can protect the application from XSS.  Using modern web frameworks(React, Vue, Angular etc..), developers cover majority of the cases, but specific to the frameworks used, there are still minute gaps that can lead to serious damage. Output Encoding and Input Sanitization can act as critical defenses against XSS.  Output Encoding Output Encoding can be helpful when the application wants to safely display the data as the user as typed. Similar to SQL injections, here the input obtained from the user should be interpreted as text and not the part of the code.  How to implement it? Most frameworks perform output encoding by default, however, if you are not using a framework, then every variable in the user interface should be passed through an Output Encoding function.  Since different browsers parse HTML, CSS and JS differently, it is important to use appropriate encoding method, else it may introduce weaknesses as well as disturb the functionality of your application.  Output encoding prevents these attacks by converting the special characters that can trigger XSS, such as &lt;, &gt;, \", ' and &amp; into harmless HTML entities, such as &amp;lt;, &amp;gt;, &amp;quot;, &amp;apos;, and &amp;amp;. This way, the browser will treat the data as plain text and not as code.  Some popular Output Encoding Methods include: \tOWASP’s ESAPI \tPHP’s htmlspecialchars() \t.NET’s HtmlEncode() \tPython’s html.escape  HTML Context  This refers to inserting variable between two basic HTML tags like a &lt;div&gt; or a &lt;p&gt;.  For eg. &lt;div&gt; $unsafVar &lt;/div&gt;   An attacker could modify this $unsafeVar variable, which could lead to an attack.  &lt;div&gt; &lt;script&gt; alert('XSS') &lt;/script&gt; &lt;/div&gt;   To add a variable to a HTML context safely, HTML entity encoding can be used. When using JavaScript, .textContent attribute can be a safe way to add a variable.  HTML Attribute Contexts  This refers to when a variable is placed in a HTML attribute value. &lt;div attr='$unsafeVar'&gt; &lt;div attr=”*x” onblur=”alert(1)*”&gt;   It is important to surround the variable names with ' or \", as it makes it difficult for the attacker to change the context.  When using JavaScript, .setAttribute methods can prove as a defensive technique against XSS. These are relatively safe when attribute names are hard-coded such as id or class.  Attributes such as onmouseover, onclick etc are NOT safe to use with untrusted attribute values.  JavaScript Contexts  This refers to when variables are placed into inline JavaScript and then embedded into HTML document. The only secure way to place this way is to quote them. All other contexts are unsafe and not recommended. &lt;script&gt;alert('$variable')&lt;/script&gt; &lt;script&gt;x='$variable'&lt;/script&gt; &lt;div onclick=\"'$variable'\"&gt;&lt;/div&gt;  This way XSS can be prevented securely.  For JSON, the Content-Type should be application/json and not text/html to prevent XSS.  CSS Contexts  When variables are placed into inline CSS, the variables should only be placed in CSS property value. Other CSS contexts are unsafe and variable data should not be placed in them.  &lt;style&gt;selector {property : $variable;} &lt;/style&gt; &lt;style&gt;selector {property : '$variable';} &lt;/style&gt; &lt;span style=\"property:$variable\"&gt;oh god&lt;/span&gt;   It is recommended to use style.property = x.  URL Contexts  URL Contexts refer to places where the developers add a parameter to a URL. This is an unsafe way to add parameter to a URL.  &lt;a href=\"http://example.com?u_id=$variable\"&gt;Link&lt;/a&gt;   To implement this safely, you should perform URL encoding followed by HTML attribute encoding:  url = \"http://example.com?u_id=\" + urlencode(parameter) &lt;a href = \"attributeEncode(url)\"&gt;Link&lt;/a&gt;   Thank You for reading. See you in the next blog!"
  },
  
  {
    "title": "SQL Injection",
    "url": "/posts/sql-injection/",
    "categories": "",
    "tags": "owasp, web",
    "date": "2025-03-07 05:30:00 +0530",
    "content": "Note: This blog is completely based on OWASP guide for prevening SQL Injection Attacks, but it is put in my own words so it can be understood in a simpler way.   SQL injection is a process of injecting or inserting a SQL query as a user input from client to application, that may lead to obtaining sensitive data from the database, modify database, shutdown the DBMS and also issue commands to OS.  Threat Modeling     It allows attackers to spoof their identity, tamper with data and become administrator of database server.   SQL injection is common in PHP and ASP applications rather than j2EE and ASP.NET applications due to their respective programmatic interfaces.   It is a high impact severity.   SQL injection attack occurs when:     An unintended data enters a program from an untrusted source.   The data is used to dynamically construct a SQL query.   Anatomy of A Typical SQL Injection Vulnerability  Input Validation:  A common SQL injection vulnerability in Java is un-validated input from the user that is taken and appended to the query, and the input is executed as a part of the query. An attacker can manipulate the query in accordance to his will.  Take a look at the below example: String query = \"SELECT balance FROM account WHERE user_name = '\"  + request.getParameter(\"customerName\")\"'\":   If an attacker passes the username as admin OR 1=1  Or admin; DROP TABLE account   The query will look something like this SELECT balance FROM account WHERE user_name = 'admin' OR 1=1;  -- OR  SELECT balance FROM account WHERE user_name = 'admin'; DROP TABLE account;  Such attacks are very dangerous and compromise the security of Organization  So, what are the solutions to prevent these? Primary Defenses  1: Use of Prepared Statements (with Parameterized Queries) 2: Use of Properly Constructed Stored Procedures 3: Allow-list Input Validation 4: STRONGLY DISCOURAGED: Escaping All User Supplied Input   1. Parameterized queries (Prepared Statements)  The correct way to prevent SQL injection is to never concatenate user input directly into the query instead use parameterized queries (Prepared Statements). This ensures that the user input is treated as data and not the part of SQL code.  String query = \"SELECT balance FROM account WHERE user_name = ?\"; PreparedStatement stmt = connection.prepareStatement(query); stmt.setString(1,request.getParameter(\"customerName\")); ResultSet result = stmt.executeQuery();   This way the attacker will never be able to inject malicious SQL queries as input. Almost all the languages support parameterized queries. Even SQL abstraction layers like HQL (Hibernate Query Language) faces similar type of injection problems called HQL injection. Using prepared statements also makes your application relatively database independent.  2. Stored Procedures  Even though Stored procedures are not always safe from SQL injections, developers can use certain standard stored procedures constructs that are generally safe if implemented accordingly. Are they Safe?  To ensure security, the developers are required to create SQL statements with parameters that are automatically parameterized. The basic difference between prepared statements and stored procedures is that the SQL code for a stored procedure is stored in the database itself, and is called by the application. Hence making parameterized queries and stored procedures equally effective in safeguarding the application from SQL injection.  When use of Stored Procedures are a risk?  Stored Procedures can be a risk when a system is attacked. Consider an example where an application uses a MS SQL Server, with default roles like db_datareader , db_datawriter and db_owner. Before stored procedures came into use, DBAs (Database Administrators) would assign roles to users, depending on the requirements.  The default roles like  db_datareader , db_datawriter do not have rights to execute stored procedures, and in organizations where user management is centralized with just these 3 default roles, assigning db_owner to users would to a potential risk. If an attacker gains access to any of the users or a server, the attacker will have full rights to the database, where previously they had only read access.  A Secure Stored Procedure Example in Java // This input should be validated in terms of length and allowed characters using regular expressions String custname = request.getParameter(\"customerName\"); try { \tcallableStatement cs = connection.prepareCall(\"{call sp_getBalance(?)}\"); \tcs.setString(1,custname); \tResultSet rs = cs.executeQuery(); \t//manipulating recieved data } catch (SQLexception){ \t//logging and error messsage display }   This example uses Java’s stored procedure implementation using callableStatement to execute database queries. Where sp_getBalance is a stored procedure predefined in the database. The call in the {call sp_getBalance(?) is used to call the stored procedure and the ? represents the parameter placeholder.  3. Allow-List Input Validation  When faced with SQL queries that can’t use bind variables (parameterized queries) such as names of tables or columns and the sort order indicators (ASC or DESC) as well, input validation is the best defense. When names of tables and columns are needed, they should come from the code and not the user parameters.  A Secure Sample Example For Allow-List Input Validation  If user parameter values are used to target different tables and columns, then it is merely a symptom of a poor design and a full-redesigning should be considered. Otherwise the developers should map the parameter values to legal/valid table and column names, preventing the user input from ending up in the query.  Take a look at the Dynamic SQL generation String tableName; switch(parameter){ \tcase \"valueA\": \t\ttableName = \"ordersTable\"; \t\tbreak; \tcase \"valueB\": \t\ttableName = \"shippedTable\"; \t\tbreak; \tdefault: \t\tthrow new InpuExceptionError(\"Invalid input for table name\"); }   In the above example the tableName is declared and using switch, the user input i.e parameter is validated and a value is assigned to tablename depending upon different cases. If input is valueA then the value of tableName will be \"ordersTable\". The default block handles the errors and exceptions effectively. Here the query is dynamically generated based on the user input but it is secure as it is validated prior to acceptance.  When to use this Allow-List Input Validation ?  When we say stored procedures are safe, It is assumed that the stored procedures do not include dynamic SQL code generation. It is usually avoided by the developers. But in some scenarios, if there is a need for dynamic SQL code generation, the Allow-list input method or proper escaping must be used to secure the program.  A safer way to implement Dynamic Query Generation  For something simple like sort order, it would be a better way to first convert the user supplied data to boolean and then use the boolean value to determine the legal value, that is appended to the query.  For example public String someMethod (boolean parameter) { \tString query = \" SELECT * FROM employees ORDER BY salary \" + (parameter ? \"ASC\" : \"DESC\"); \treturn query; }   Like the above example, if possible it is always safer to convert any user input to a non-string format like integer, boolean, time, date, etc. before it is appended to query or used to select a value to append to a query.  Input validation is recommended as a secondary defense in all cases even when using prepared statements or stored procedures to ensure maximum security.  4. Escaping All User-Supplied Input  In this approach, the developer will have to escape all the input supplied by the user before appending it to a query. Escaping input refers to ensuring that any special characters in user-supplied input are converted or escaped into a safe form before they are included in an SQL query. This defense method is highly discouraged as it does not guarantee safety due to various limitations.  How does Escaping work?  For each special character that might interfere with the query, you replace or escape it with a safe equivalent. Different Databases have different ways of handling escaping.  Below are few common SQL special characters and their functions    Single Quote ('): Used to delimit strings in SQL.   Double Quote (\"): Often used for quoting column or table names.   Backslash (\\): Used as an escape character in many SQL implementations.   Semicolon (;): Indicates the end of a SQL statement.   Comment (-- or /* ... */): Allows attackers to comment out the remainder of a query.   Escaping single quotes ('):  Take a look at below query String query = 'SELECT * FROM accounts WHERE username = ' + request.getParameter(\"custName\"); ResultSet rs = stmt.executeQuery(query);   If the user supplied input is O'Rielly, then the query will break and result in error.  To avoid broken queries, the developer must escape the (') manually. This can be done using doubling the single quotes ('').  A solution to escaping only single quotes (') in Java  String UserInput = request.getParameter(\"custName\"); //Input = O'Rielly String EscapedInput = UserInput.replace(\"'\",\"''\"); //Now manually construct the query String query = \"SELECT * FROM accounts WHERE username = '\" + EscapedInput + \"'\"); ResultSet rs = stmt.executeQuery(query);   This example will not return errors, when provided with input O'Rielly. Similarly for different special characters, different escaping methods are to be used. But such practices are highly discouraged as escaping all the user input is very unsafe. Even though the developers cover all edge cases, there is still a huge risk of SQL injection attacks. Better Alternatives like prepared statements are highly recommended.  Additional Defenses  In Addition to implementing any one of the four primary defenses, these additional defenses can also be implemented for maximizing the security of the application. The additional defenses are:    Least Privilege   Allow-List Input Validation   Least Privilege  To minimize the damage of a successful SQL injection attack, consider minimizing the privileges assigned to the every database account in your environment i.e The principle of least privilege (PoLP). Use Bottom-Up approach, always start from what access the application accounts require rather than focusing what access you need to take away.  Accounts that require to only read the data should be given only read privileges and follow the same for write, provide only if absolutely necessary. DO NOT grant DBA or ADMIN privileges to any of the application accounts. Even though it is easy to do so and everything just functions normally but it is extremely dangerous.  What is an Application Account?  Application Account refers to a database user account that acts as a bridge between the web application and the database. It is not a person or a software It is just the database account that the web application software uses to store or retrieve data from the database. Any Application account should not contain Admin privileges like DROP,DELETE or ALTER.  Minimizing Application and OS privileges  Application privilege  In addition to SQL injection Attacks, there exist other threats to your database data, such as attackers manipulating the parameters from a legal value that is authorized for their current account to a value that is unauthorized for them (only meant to be accessible to root or the the admin).  For Example Consider an application where user-supplied input is appended to query the database directly. Even if the user-input is validated using javaScript, the attacker could still modify the URL like this: https://flipkart.com/product?id=322  To https://flipkart.com/product?id=999        //To be accessed only by admin   Since the user-input validation is on the client-side, the attacker can easily bypass the authentication. This is why the input-validation should always be done on the server side where attacker has no control. Even if an attacker gains access to a Application account, to minimize the damage, the privileges assigned to the account should be minimal.  OS privilege  The OS (Operating System) Account under which the DBMS (Database Management System) runs under should never be run as root or system. By default most DBMSs run as system account which is very powerful and dangerous. It is recommended to run the DBMS with an appropriate account with restricted privileges.  To create a new user:  Login to MySQL as root user sudo mysql -u root -p   Now create a new user with restricted privileges using the following command CREATE USER 'user_a'@'localhost' IDENTIFIED BY 'password'; GRANT SELECT ON mydatabase.* TO 'user_a'@'localhost'; FLUSH PRIVILEGES;   This way only the necessary privileges are to be assigned to the user account on the OS that runs the DBMS. To create new user application accounts on the database to be accessed from different devices, the 'localhost' should be simply replaced by ('%') meaning that it allows any host with the password to access the database which might be a threat if passwords are weak. So it is recommended to limit the access for IP range using '192.13.32.%'. This provides remote access and also maintaining security.  Additional Measures When Developing  When assigning privileges, if an application account needs access to only few tables, consider creating a VIEW that limits only to required data and providing access to only that view instead, rather that the actual table.  If you plan to use stored procedures everywhere, then do not allow application accounts to execute queries directly, rather only allow them to execute stored procedures that they require. Avoid giving them direct access to tables in the database.  Least Admin Privileges For Multiple Database User Accounts  The developers should refrain from using the same root or admin account for multiple web applications to connect to the database. Different application accounts are to be used for different web applications.  Each and every web application must have a designated database account with least privileges that it requires to connect to the database. This can help reduce the privileges to the web applications.  For example, consider a ‘Login’, ‘Sign-Up’ and ‘Profile Page’ web applications. Here providing admin or same account to all three web applications would be a poor decision. The ‘Login’ requires only SELECT access, whereas ‘Sign-Up’ requires only INSERT access and the ‘Profile Page’ application requires SELECT , INSERT and UPDATE access. Hence least privilege can be maximized.  Enhancing Least Privilege with SQL Views  You can use SQL views to enhance the granularity of access by limiting the read access to specific data of a table. For Example, consider storing password in plain-text instead of salty-hash values (due to specific legal requirements) in the table. If an application account is to be given access to the passwords, then a view is to be generated that depicts the hash values of the passwords. The access to the tables in the database is revoked from all the DB users except admin.  If a successful SQL injection attack occurs, the attacker might have access to only salted-hash values of the passwords and not the plain-text passwords, Since no application user has access to the table itself.  Allow-List Input Validation  As mentioned earlier implementing Input Validation as a primary defense only if nothing else works, but implementing it as a secondary defense in highly recommended to improve security. As explained in above section, it is used to detect unauthorized input before appending to the query. Proceed with caution, Input validation is highly discouraged as a primary defense, unless it is the only option.  That’s a wrap. Firstly, congratulations on making it so far. You have done a great job, wishing you Best of luck!"
  }
  
]

